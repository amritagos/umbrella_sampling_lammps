import math
from pathlib import Path
from typing import Optional, Tuple
import numpy as np
from snakemake.script import snakemake
import toml
import matplotlib.pyplot as plt


def read_output_wham(filename: Path | str) -> np.ndarray:
    """
    Reads the output generated by WHAM and extracts the PMF

    :param filename: WHAM output file
    :type filename: Path | str
    :return: an array with reaction coordinate and the PMF
    :rtype: ndarray[_AnyShape, dtype[Any]]
    """
    coor_data = []
    with open(filename, "r") as file:
        section = None
        for line in file:
            if "#Coor" in line:
                section = "coor"
            elif "#Window" in line:
                section = "window"
            if (section == "coor") and ("#" not in line):
                parts = line.split("\t")
                coor_data.append([np.float32(parts[0]), np.float32(parts[1])])
    return np.array(coor_data)


def plot_histograms(
    time_series_paths: list[Path], outfile: Path, nbins: Optional[int] = 50
) -> None:
    """
    Plots histograms of all umbrella windows, such that alternating histograms have the same colour.
    The reaction coordinate is the x coordinate

    :param time_series_paths: Each file contains the time series information (time, reaction coordinate) for each umbrella window.
    :type time_series_paths: list[Path]
    :param outfile: Path to the output PNG
    :param nbins: Number of bins used for histogramming
    """
    color1 = np.array([1.0, 0.682, 0.286])
    color2 = np.array([0.008, 0.294, 0.478])

    if nbins is None:
        nbins = 50

    fig1, ax1 = plt.subplots(figsize=(12, 8))

    for i, time_series_path in enumerate(time_series_paths):
        data = np.loadtxt(time_series_path)
        x = data[:, 1]  # averaged reaction coordinate
        a, b = np.histogram(x, bins=nbins)
        centers = (b[1:] + b[:-1]) / 2
        a = a / np.sum(a)

        if (i + 1) % 2 == 0:
            ax1.plot(
                centers,
                a,
                "-",
                linewidth=3,
                markersize=12,
                color=color1,
                label=f"window {i+1}" if i + 1 == 2 else None,
            )
        else:
            ax1.plot(
                centers,
                a,
                "-",
                linewidth=3,
                markersize=12,
                color=color2,
                label=f"window {i+1}" if i + 1 == 1 else None,
            )

    ax1.set_xlabel(r"$x ~ (\mathrm{\AA})$")
    ax1.set_ylabel("normalized count")
    ax1.set_title("Umbrella window overlap")
    ax1.legend(loc="best")
    fig1.tight_layout()

    fig1.savefig((outfile), dpi=600, bbox_inches="tight")


def get_energy_and_forces(
    sigma: float,
    epsilon: float,
    delta: float,
    x0: float,
    xmin: float = -50,
    xmax: float = 50,
    npoints: int = 10000,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Calculates the energy and forces of the imposed potential, for the example

    :param sigma: LJ sigma parameter (Angstrom)
    :type sigma: float
    :param epsilon: LJ epsilon parameter (kcal/mol)
    :type epsilon: float
    :type delta: float
    :type x0: float
    :param xmin: Minimum of the range in the x coordinate (for plotting)
    :type xmin: float
    :param xmax: Maximum of the range in the x coordinate (for plotting)
    :type xmax: float
    :param npoints: Number of points in the range to calculate energy and forces for
    :type npoints: int
    :return: Returns the energy and forces
    :rtype: Tuple[np.ndarray, np.ndarray]
    """
    U0 = 10 * epsilon  # Kcal/mol
    x = np.linspace(xmin, xmax, npoints)  # Angstrom

    U = U0 * np.arctan((x + x0) / delta) - U0 * np.arctan((x - x0) / delta)
    F = (
        U0 / (((x - x0) ** 2) / delta**2 + 1) / delta
        - U0 / (((x + x0) ** 2) / delta**2 + 1) / delta
    )
    return U, F


def plot_pmf(
    infile: Path,
    outfile: Path,
    sigma: float,
    epsilon: float,
    delta: float,
    x0: float,
    xmin: float = -50,
    xmax: float = 50,
    npoints: int = 10000,
) -> None:
    """
    Plots the PMF and compares to the reference (known) potential
    """

    output_wham = read_output_wham(infile)

    # Initialise figure
    fig, ax = plt.subplots(figsize=(6, 4))
    color = np.array([0.267, 0.647, 0.761])

    # WHAM data
    x_wham = output_wham[:, 0]
    pmf_wham = output_wham[:, 1]

    # Normalise WHAM PMF to minimum = 0
    pmf_wham -= pmf_wham.min()

    # Analytic potential on a grid (can use same range as before)
    U, F = get_energy_and_forces(
        sigma,
        epsilon,
        delta,
        x0,
        xmin,
        xmax,
        npoints,
    )
    x_ref = np.linspace(xmin, xmax, npoints)

    # Normalise analytic U to minimum = 0
    U -= U.min()

    # WHAM output
    ax.plot(
        x_wham,
        pmf_wham,
        "o-",
        linewidth=3,
        markersize=12,
        color=color,
        label="WHAM",
    )

    # Imposed potential
    ax.plot(
        x_ref,
        U,
        "-",
        linewidth=3,
        color=np.array([0.2, 0.2, 0.2]),
        label="Imposed potential",
    )

    ax.set_xlabel(r"$x ~ (\mathrm{\AA})$")
    ax.set_ylabel(r"$U~(\mathrm{kcal/mol})$")
    ax.legend(loc="best")
    fig.tight_layout()

    fig.savefig(outfile, dpi=600, bbox_inches="tight")


if __name__ == "__main__":
    time_series_abs_paths = snakemake.params["abs_paths"]
    pmf_input = Path(snakemake.input["pmf"])
    xmin = float(snakemake.params["xmin_pmf_plot"])
    xmax = float(snakemake.params["xmax_pmf_plot"])
    histogram_output = Path(snakemake.output["histogram_plot"])
    pmf_plot_output = Path(snakemake.output["pmf_plot"])
    # Parameters for the imposed potential (TODO: read these in from Snakemake too)
    sigma = 3.405  # Angstrom
    epsilon = 0.238  # Kcal/mol
    delta = 1.0  # Angstrom
    x0 = 10.0  # Angstrom

    plot_histograms(time_series_abs_paths, histogram_output)
    plot_pmf(
        pmf_input,
        pmf_plot_output,
        sigma,
        epsilon,
        delta,
        x0,
        xmin,
        xmax,
    )
