import pandas as pd
from pathlib import Path
from snakemake.utils import min_version
import numpy as np


configfile: "config/general_config.yml"  # Path to config file containing general variables, relative to the workflow folder


# Load the sample data from the generated CSV file.
# IMPORTANT: Make sure to generate the samples.csv file with the generate_samples.py script!
samples = (
    pd.read_csv(config["samples"], dtype={"sample_name": str})
    .set_index("sample_name", drop=False)
    .sort_index()
)

SAMPLES_IDX_START = int(config.get("samples_idx_start", 0))
SAMPLES_IDX_END = int(config.get("samples_idx_end", len(samples)))

print(f"{SAMPLES_IDX_START=}")
print(f"{SAMPLES_IDX_END=}")

samples = samples[SAMPLES_IDX_START:SAMPLES_IDX_END]

NUM_THREADS = int(config["mpi_threads"])

min_version("6.0")

results_dir = config["results_dir"]

source_cmd = config["lammps"]["source_cmd"]

lmp = config["lammps"]["lmp_cmd"]


rule all:
    input:
        expand(
            "{results_dir}/equil/{sample}/equilibrated.data",
            results_dir=results_dir,
            sample=samples.index,
        ),
        expand(
            "{results_dir}/equil2/{sample}/system.data",
            results_dir=results_dir,
            sample=samples.index,
        ),
        expand(
            "{results_dir}/umbrella_sampling/{sample}/inp.dat",
            results_dir=results_dir,
            sample=samples.index,
        ),
        expand(
            "{results_dir}/umbrella_sampling/{sample}/system.data",
            results_dir=results_dir,
            sample=samples.index,
        ),
        expand(
            "{results_dir}/wham_analysis/pmf.dat",
            results_dir=results_dir,
        ),
        expand(
            "{results_dir}/wham_analysis/pmf.png",
            results_dir=results_dir,
        ),


# Rule for running a LAMMPS script that can be inherited from
rule lammps_run:
    input:
        run_file=[],
    resources:
        cpus_per_task=1,
        ntasks_per_node=NUM_THREADS,
    threads: NUM_THREADS
    output:
        data=[],
        out=[],
    shell:
        f"""
        {source_cmd}
        export OMP_NUM_THREADS={{resources.cpus_per_task}}
        cd $( dirname {{input.run_file}})
        mpirun -n {{resources.ntasks_per_node}} {lmp} -in inp.dat 
        """


# Create a LAMMPS input file
rule create_input:
    localrule: True
    threads: 1
    input:
        template=[],
        potential_file=[],
    params:
        "",
    output:
        run_file=[],
    script:
        workflow.source_path("scripts/render_jinja2.py")


rule copy:
    """
    Copy multiple files into the output directory.
    - Creates directory if missing
    - Overwrites existing files (but keeps the directory)
    """
    localrule: True
    input:
        files=[],  # files to copy
        deps=[],  # optional dependencies that aren’t copied
    output:
        outfile=[],
    threads: 1
    run:
        import shutil
        from pathlib import Path

        outdir = Path(output.outfile).parent
        outdir.mkdir(parents=True, exist_ok=True)

        for f in input.files:
            src = Path(f)
            dst = outdir / src.name
            shutil.copy2(src, dst)  # overwrite if exists
            print(f"Copied {src} -> {dst}")


# -----------------------------------
# Equilibration


# TODO: add temperature as a parameter
# Create input file for equilibration
use rule create_input as lammps_input_equil with:
    localrule: True
    threads: 1
    retries: 1  # for latency on clusters 
    input:
        template=config["lammps"]["template_file"],
    params:
        equil=1,
        umbrella_center=lambda wc: samples.loc[wc.sample, "umbrella_center"],
        seed=lambda wc: samples.loc[wc.sample, "run_number"],
        run_steps=config["equilibration"]["run_steps"],
        template_folder=f"{results_dir}/templates",
    output:
        run_file=ensure("{results_dir}/equil/{sample}/inp.dat", non_empty=True),


# Run the equilibration
use rule lammps_run as lammps_run_equilibration with:
    input:
        run_file=rules.lammps_input_equil.output.run_file,
    threads: NUM_THREADS
    output:
        data="{results_dir}/equil/{sample}/equilibrated.data",


# --------------------------------

# First run the umbrella sampling for a certain number of steps (to discard it)


# TODO: add temperature as a parameter
# Create an input file for the umbrella window
use rule create_input as lammps_input_umbrella_equil with:
    localrule: True
    threads: 1
    retries: 1  # for latency on clusters 
    input:
        template=config["lammps"]["template_file"],
        data=rules.lammps_run_equilibration.output.data,
    params:
        umbrella_sampling_with_colvars=1,
        colvars_input_filename="colvars.in",
        in_data=lambda wc, input: Path(input.data).resolve(),
        timestep=config["umbrella_sampling"]["timestep"],
        run_steps=config["umbrella_sampling"]["discard_steps"],
        seed=lambda wc: samples.loc[wc.sample, "run_number"],
        template_folder=f"{results_dir}/templates",
    output:
        run_file=ensure("{results_dir}/equil2/{sample}/inp.dat", non_empty=True),


# Create an input COLVARS file
use rule create_input as colvars_input_equil with:
    localrule: True
    threads: 1
    retries: 1  # for latency on clusters 
    input:
        template=config["umbrella_sampling"]["colvars_template_file"],
        data=rules.lammps_run_equilibration.output.data,
    params:
        umbrella=1,
        output_frequency=config["umbrella_sampling"]["output_frequency"],
        colvar_variable_name=config["umbrella_sampling"]["colvar_variable_name"],
        lower_boundary=config["umbrella_sampling"]["lower_boundary"],
        upper_boundary=config["umbrella_sampling"]["upper_boundary"],
        axis=[1.0, 0.0, 0.0],
        atom_type=1,
        center=lambda wc: samples.loc[wc.sample, "umbrella_center"],
        force_constant=config["umbrella_sampling"]["umbrella_spring_constant"],
        template_folder=f"{results_dir}/templates",
    output:
        colvars_input=ensure("{results_dir}/equil2/{sample}/colvars.in", non_empty=True),


# Run the equilibration
use rule lammps_run as lammps_run_umbrella_equil with:
    input:
        run_file=rules.lammps_input_umbrella_equil.output.run_file,
        colvars_input=rules.colvars_input_equil.output.colvars_input,
    threads: NUM_THREADS
    output:
        data="{results_dir}/equil2/{sample}/system.data",
        time_series="{results_dir}/equil2/{sample}/out.colvars.traj",

# --------------------------------

# Umbrella sampling
# Create the windows and run, starting from the equilibrated configuration


# TODO: add temperature as a parameter
# Create an input file for the umbrella window
use rule create_input as lammps_input_umbrella with:
    localrule: True
    threads: 1
    retries: 1  # for latency on clusters 
    input:
        template=config["lammps"]["template_file"],
        data=rules.lammps_run_umbrella_equil.output.data,
    params:
        umbrella_sampling_with_colvars=1,
        in_data=lambda wc, input: Path(input.data).resolve(),
        colvars_input_filename="colvars.in",
        timestep=config["umbrella_sampling"]["timestep"],
        run_steps=config["umbrella_sampling"]["run_steps"],
        seed=lambda wc: samples.loc[wc.sample, "run_number"],
        template_folder=f"{results_dir}/templates",
    output:
        run_file=ensure(
            "{results_dir}/umbrella_sampling/{sample}/inp.dat", non_empty=True
        ),


# Create an input COLVARS file
use rule create_input as colvars_input_production with:
    localrule: True
    threads: 1
    retries: 1  # for latency on clusters 
    input:
        template=config["umbrella_sampling"]["colvars_template_file"],
        data=rules.lammps_run_equilibration.output.data,
    params:
        umbrella=1,
        output_frequency=config["umbrella_sampling"]["output_frequency"],
        colvar_variable_name=config["umbrella_sampling"]["colvar_variable_name"],
        lower_boundary=config["umbrella_sampling"]["lower_boundary"],
        upper_boundary=config["umbrella_sampling"]["upper_boundary"],
        axis=[1.0, 0.0, 0.0],
        atom_type=1,
        center=lambda wc: samples.loc[wc.sample, "umbrella_center"],
        force_constant=config["umbrella_sampling"]["umbrella_spring_constant"],
        template_folder=f"{results_dir}/templates",
    output:
        colvars_file=ensure(
            "{results_dir}/umbrella_sampling/{sample}/colvars.in", non_empty=True
        ),


# Run the equilibration
use rule lammps_run as lammps_run_umbrella with:
    input:
        run_file=rules.lammps_input_umbrella.output.run_file,
        colvars_file=rules.colvars_input_production.output.colvars_file,
    threads: NUM_THREADS
    output:
        data="{results_dir}/umbrella_sampling/{sample}/system.data",
        time_series="{results_dir}/umbrella_sampling/{sample}/out.colvars.traj",


# -------------------------
# WHAM

# sort samples by run_number
sorted_samples = samples.sort_values("run_number").index


# Create the meta file which will contain all the time series information
rule create_wham_meta:
    localrule: True
    threads: 1
    input:
        time_series_paths=expand(
            rules.lammps_run_umbrella.output.time_series,
            results_dir=results_dir,
            sample=sorted_samples,
        ),
    output:
        wham_meta="{results_dir}/wham_analysis/umbrella-sampling.meta",
    params:
        abs_paths=lambda wc, input: [
            str(Path(p).resolve()) for p in input.time_series_paths
        ],
        umbrella_centers=[samples.loc[s, "umbrella_center"] for s in sorted_samples],
        spring_constants=[
            config["umbrella_sampling"]["umbrella_spring_constant"]
            for s in sorted_samples
        ],
    script:
        workflow.source_path("scripts/create_meta.py")


rule wham:
    localrule: True
    threads: 1
    input:
        wham_meta=rules.create_wham_meta.output.wham_meta,
    params:
        units="real",
        reaction_coordinate_min=-30,
        reaction_coordinate_max=30,
        nbins=50,
        tolerance=1e-8,
        temperature=119.8,  # in Kelvin (TODO: put in config)
        numpad=0,  # numpad specifies the number of “padding” values that should be printed for periodic free energy curve. This number should be set to 0 for aperiodic reaction coordinates.
    output:
        pmf="{results_dir}/wham_analysis/pmf.dat",
    log:
        "{results_dir}/wham_analysis/wham.log",
    shell:
        f"""
        wham units {{params.units}} {{params.reaction_coordinate_min}} {{params.reaction_coordinate_max}} {{params.nbins}} {{params.tolerance}} {{params.temperature}} {{params.numpad}} {{input.wham_meta}} {{output.pmf}} > {{log}} 2>&1
        """


umbrella_centers_sorted = [samples.loc[s, "umbrella_center"] for s in sorted_samples]


rule plot_pmf:
    localrule: True
    threads: 1
    input:
        pmf=rules.wham.output.pmf,
        time_series_paths=expand(
            rules.lammps_run_umbrella.output.time_series,
            results_dir=results_dir,
            sample=sorted_samples,
        ),
    params:
        abs_paths=lambda wc, input: [
            str(Path(p).resolve()) for p in input.time_series_paths
        ],
        xmin_pmf_plot=np.min(umbrella_centers_sorted) - 20,
        xmax_pmf_plot=np.max(umbrella_centers_sorted) + 20,
    output:
        histogram_plot="{results_dir}/wham_analysis/histograms.png",
        pmf_plot="{results_dir}/wham_analysis/pmf.png",
    script:
        workflow.source_path("scripts/plot_pmf_histo.py")
